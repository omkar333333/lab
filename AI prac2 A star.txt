import heapq

# Heuristic Function: Manhattan Distance
def manhattan_distance(state, goal):
    distance = 0
    for i in range(1, 9):
        x1, y1 = divmod(state.index(i), 3)
        x2, y2 = divmod(goal.index(i), 3)
        distance += abs(x1 - x2) + abs(y1 - y2)
    return distance


# Function to get next possible moves
def get_neighbors(state):
    neighbors = []
    index = state.index(0)  # 0 is the blank tile
    x, y = divmod(index, 3)

    moves = []
    if x > 0: moves.append((-1, 0))
    if x < 2: moves.append((1, 0))
    if y > 0: moves.append((0, -1))
    if y < 2: moves.append((0, 1))

    for dx, dy in moves:
        new_x, new_y = x + dx, y + dy
        new_index = new_x * 3 + new_y
        new_state = list(state)
        new_state[index], new_state[new_index] = new_state[new_index], new_state[index]
        neighbors.append(tuple(new_state))

    return neighbors

# A* Algorithm
def a_star(start, goal):
    open_list = []
    heapq.heappush(open_list, (0 + manhattan_distance(start, goal), 0, start, []))
    visited = set()

    while open_list:
        f, g, current, path = heapq.heappop(open_list)

        if current in visited:
            continue
        visited.add(current)

        if current == goal:
            return path + [current]

        for neighbor in get_neighbors(current):
            if neighbor not in visited:
                new_g = g + 1
                new_f = new_g + manhattan_distance(neighbor, goal)
                heapq.heappush(open_list, (new_f, new_g, neighbor, path + [current]))

    return None


# --- Main Program ---
if __name__ == "__main__":
    # Represent puzzle as a tuple (0 = blank)
    start_state = (1, 2, 3,
                   4, 0, 6,
                   7, 5, 8)
    goal_state = (1, 2, 3,
                  4, 5, 6,
                  7, 8, 0)

    print("Starting A* Search...\n")
    path = a_star(start_state, goal_state)

    if path:
        print("Steps to reach goal:\n")
        for step in path:
            print(step[0:3])
            print(step[3:6])
            print(step[6:9])
            print()
        print(f"Total moves: {len(path) - 1}")
    else:
        print("No solution found.")
